<!DOCTYPE html>
<html>
  <head>
    <title>Simple Roguelike v2</title>
  </head>
  <body>
        <div id="canvas"></div>
        <div id="help">
        <h2>How To Play</h2>
        <ul>
          <li>Use number pad keys for movement</li>
          <li>Or, use <code>WASD</code> for cardinal movement and <code>QEZC</code> for diagonal movement</li>
          <li>Use <code>i</code> to open your inventory</li>
        </ul>
        <h3>Attacking</h3>
        <p>Walk into enemies</p>
        <h3>Legend</h3>
        <table border=1>
          <thead>
              <tr>
                  <th>Character</th>
                  <th>Description</th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td><span style="font-family: monospace; color:blue">@</span></td>
                  <td>Player</td>
              </tr>
              <tr>
                  <td><span style="font-family: monospace; color:green">G</span></td>
                  <td>Goblin</td>
              </tr>
              <tr>
                  <td><span style="font-family: monospace;">%</span></td>
                  <td>Corpse</td>
              </tr>
              <tr>
                  <td><span style="font-family: monospace; color:brown">*</span></td>
                  <td>Chest</td>
              </tr>
          </tbody>
        </table>
        </div>
        <script src="/js/rot.min.js"></script>
        <script>
        
            function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

            function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

            function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

            function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

            function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

            function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

            function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

            function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

            function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

            var WIDTH = 65;
            var HEIGHT = 40;
            var currentWindowInputHandler = null;

            var createHealthPotion = function createHealthPotion(hp) {
              var heal = function heal() {
                if (Game.player.fighter.hp == Game.player.fighter.max_hp) {
                  Game.displayMessage('You are already at full health.');
                  return;
                }

                Game.player.fighter.heal(hp);
              };

              return new Item("Health Potion of +" + hp, heal);
            };

            var showMenu = function showMenu(header, options, width) {
              if (options.length > 26) {
                console.error("too many options");
                return;
              }

              var aCode = "a".charCodeAt(0); // add one for header

              var height = options.length + 4; // draw background

              for (var w = 0; w < width; w++) {
                for (var h = 0; h < height; h++) {
                  if (w === 0 || h === 0 || w === width - 1 || h === height - 1) {
                    Game.display.draw(w, h, "1", "grey", "grey");
                  } else {
                    Game.display.draw(w, h, "1", "black", "black");
                  }
                }
              }

              Game.display.drawText(2, 1, "%c{white}%b{black}" + header);

              for (var i = 0; i < options.length; i++) {
                Game.display.drawText(2, i + 3, "%c{white}%b{black}" + String.fromCharCode(i + aCode) + ": " + options[i]);
              }
            };

            var Fighter =
            /*#__PURE__*/
            function () {
              function Fighter(hp, maxHp, strength, defense) {
                var deathCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

                _classCallCheck(this, Fighter);

                _defineProperty(this, "owner", null);

                this.hp = hp;
                this.maxHp = maxHp;
                this.strength = strength;
                this.defense = defense;
                this.deathCallback = deathCallback;
              }

              _createClass(Fighter, [{
                key: "takeDamage",
                value: function takeDamage(damage) {
                  if (damage > 0) {
                    this.hp -= damage;
                  }

                  if (this.hp <= 0 && this.deathCallback !== null) {
                    this.deathCallback(this.owner);
                  }
                }
              }, {
                key: "attack",
                value: function attack(target) {
                  var damage = this.strength - target.fighter.defense;

                  if (damage > 0) {
                    Game.displayMessage(this.owner.name + " attacks " + target.name + " for " + damage + " damage.");
                    target.fighter.takeDamage(damage);
                  } else {
                    Game.displayMessage(this.owner.name + " attacks " + target.name + ", but it's too weak!");
                  }
                }
              }, {
                key: "heal",
                value: function heal(amount) {
                  this.hp += amount;

                  if (this.hp > self.maxHp) {
                    this.hp = self.maxHp;
                  }
                }
              }]);

              return Fighter;
            }();

            var BasicMonster =
            /*#__PURE__*/
            function () {
              function BasicMonster() {
                _classCallCheck(this, BasicMonster);

                _defineProperty(this, "owner", null);
              }

              _createClass(BasicMonster, [{
                key: "act",
                value: function act() {
                  var x = Game.player.x;
                  var y = Game.player.y;

                  var passableCallback = function passableCallback(x, y) {
                    // own space is passable
                    if (this.owner.x === x && this.owner.y === y) {
                      return true;
                    }

                    return !Game.isBlocked(x, y);
                  };

                  var astar = new ROT.Path.AStar(x, y, passableCallback.bind(this), {
                    topology: 4
                  });
                  var path = [];

                  var pathCallback = function pathCallback(x, y) {
                    path.push([x, y]);
                  };

                  astar.compute(this.owner.x, this.owner.y, pathCallback);
                  path.shift();
                  /* remove Pedro's position */

                  if (path.length == 1) {
                    this.owner.fighter.attack(Game.player);
                  } else {
                    if (path.length === 0) {
                      return;
                    }

                    x = path[0][0];
                    y = path[0][1];
                    Game.drawTile(this.owner.x + "," + this.owner.y, this.owner.x, this.owner.y);
                    this.owner.x = x;
                    this.owner.y = y;
                  }
                }
              }], [{
                key: "die",
                value: function die(target) {
                  Game.displayMessage(target.name + " has been killed");
                  target.char = '%';
                  target.fgcolor = "green";
                  target.bgcolor = "darkred";
                  target.blocks = false;
                  target.fighter = null;
                  target.ai = null;
                  target.name = 'remains of ' + target.name;
                }
              }]);

              return BasicMonster;
            }();

            var GameObject =
            /*#__PURE__*/
            function () {
              function GameObject(x, y, char, fgcolor, bgcolor, name) {
                var blocks = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
                var fighter = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
                var ai = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;

                _classCallCheck(this, GameObject);

                this.x = x;
                this.y = y;
                this.char = char;
                this.fgcolor = fgcolor;
                this.bgcolor = bgcolor;
                this.name = name;
                this.blocks = blocks;

                if (fighter) {
                  this.fighter = fighter;
                  fighter.owner = this;
                }

                if (ai) {
                  this.ai = ai;
                  ai.owner = this;
                }
              }

              _createClass(GameObject, [{
                key: "act",
                value: function act() {
                  if (this.ai) {
                    return this.ai.act();
                  }
                }
              }, {
                key: "draw",
                value: function draw() {
                  Game.display.draw(this.x, this.y, this.char, this.fgcolor, this.bgcolor);
                }
              }]);

              return GameObject;
            }();

            var Player =
            /*#__PURE__*/
            function (_GameObject) {
              _inherits(Player, _GameObject);

              function Player() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, Player);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Player)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _defineProperty(_assertThisInitialized(_this), "keyMap", {
                  38: 0,
                  87: 0,
                  33: 1,
                  69: 1,
                  39: 2,
                  68: 2,
                  34: 3,
                  67: 3,
                  40: 4,
                  83: 4,
                  35: 5,
                  90: 5,
                  37: 6,
                  65: 6,
                  36: 7,
                  81: 7
                });

                _defineProperty(_assertThisInitialized(_this), "inventory", []);

                _defineProperty(_assertThisInitialized(_this), "checkBox", function () {
                  var key = this._x + "," + this._y;

                  if (Game.map[key] != "*") {
                    Game.displayMessage("There is no box here!");
                  } else if (key == Game.ananas) {
                    Game.displayMessage("Hooray! You found an ananas and won this game.");
                    Game.engine.lock();
                    window.removeEventListener("keydown", this);
                  } else {
                    Game.displayMessage("This box is empty");
                  }
                });

                return _this;
              }

              _createClass(Player, [{
                key: "act",
                value: function act() {
                  Game.engine.lock();
                  /* wait for user input; do stuff when user hits a key */

                  currentWindowInputHandler = this.handleKeyboardEvent.bind(this);
                  window.addEventListener("keydown", currentWindowInputHandler, {
                    once: true
                  });
                }
              }, {
                key: "handleKeyboardEvent",
                value: function handleKeyboardEvent(e) {
                  e.preventDefault();
                  var code = e.keyCode;

                  if (this.fighter === null || this.fighter.hp <= 0) {
                    return;
                  } // i for inventory


                  if (code === 73) {
                    showMenu("Player Inventory", this.inventory.map(function (i) {
                      return i.name;
                    }), WIDTH);
                    window.removeEventListener("keydown", currentWindowInputHandler);
                    currentWindowInputHandler = this.handleInventoryInput.bind(this);
                    window.addEventListener("keydown", currentWindowInputHandler);
                    return;
                  }
                  /* one of numpad directions? */


                  if (!(code in this.keyMap)) {
                    window.addEventListener("keydown", currentWindowInputHandler, {
                      once: true
                    });
                    return;
                  }
                  /* is there a free space? */


                  var dir = ROT.DIRS[8][this.keyMap[code]];
                  var newX = this.x + dir[0];
                  var newY = this.y + dir[1];
                  var newKey = newX + "," + newY;
                  var target = null;

                  for (var i = 0; i < Game.actors.length; i++) {
                    var o = Game.actors[i];

                    if (o.x == newX && o.y == newY) {
                      target = o;
                      break;
                    }
                  }

                  if (target && target.fighter) {
                    this.fighter.attack(target);
                    Game.engine.unlock();
                    return;
                  }

                  for (var i = 0; i < Game.game_objects.length; i++) {
                    var o = Game.game_objects[i];

                    if (o.x == newX && o.y == newY) {
                      target = o;
                      break;
                    }
                  }

                  if (target && target.interact) {
                    target.interact();
                    Game.engine.unlock();
                    return;
                  }

                  if (Game.isBlocked(newX, newY)) {
                    window.addEventListener("keydown", currentWindowInputHandler, {
                      once: true
                    });
                    return;
                  }

                  Game.drawTile(this.x + "," + this.y, this.x, this.y);
                  this.x = newX;
                  this.y = newY;
                  window.removeEventListener("keydown", currentWindowInputHandler);
                  Game.engine.unlock();
                }
              }, {
                key: "damage",
                value: function damage(dam) {
                  this.health -= dam;

                  if (this.health <= 0) {
                    Game.displayMessage("You loose");
                    Game.engine.lock();
                  }
                }
              }, {
                key: "handleInventoryInput",
                value: function handleInventoryInput(e) {
                  e.preventDefault();
                  var key = e.key;
                  var aCode = "a".charCodeAt(0);
                  var zCode = "z".charCodeAt(0);
                  var keyCode = key.charCodeAt(0);

                  if (keyCode < aCode && keyCode > zCode) {
                    return;
                  }

                  if (key === "Escape") {
                    Game.drawWholeMap();
                    Game.manager.act();
                    window.removeEventListener("keydown", currentWindowInputHandler);
                    currentWindowInputHandler = this.handleKeyboardEvent.bind(this);
                    window.addEventListener("keydown", currentWindowInputHandler);
                    return;
                  }

                  var index = keyCode - aCode;

                  if (index >= this.inventory.length) {
                    return;
                  }

                  var item = this.inventory[index];
                  item.use();
                  this.inventory.splice(index, 1);
                  Game.displayMessage("Used " + item.name);
                  Game.drawWholeMap();
                  window.removeEventListener("keydown", currentWindowInputHandler);
                  Game.engine.unlock();
                }
              }], [{
                key: "die",
                value: function die(target) {
                  target.char = '%';
                  target.fgcolor = "blue";
                  target.bgcolor = "darkred";
                  target.blocks = false;
                  target.name = 'remains of ' + target.name;
                  Game.displayMessage("You Died");
                }
              }]);

              return Player;
            }(GameObject);

            var Item =
            /*#__PURE__*/
            function () {
              function Item(name) {
                var useCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                _classCallCheck(this, Item);

                this.name = name;
                this.useCallback = useCallback;
              }

              _createClass(Item, [{
                key: "use",
                value: function use() {
                  if (this.useCallback === null) {
                    diplayMessage("Can't use " + this.name);
                    return;
                  }

                  this.useCallback();
                }
              }]);

              return Item;
            }();

            var Chest =
            /*#__PURE__*/
            function (_GameObject2) {
              _inherits(Chest, _GameObject2);

              function Chest() {
                var _getPrototypeOf3;

                var _this2;

                _classCallCheck(this, Chest);

                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                _this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(Chest)).call.apply(_getPrototypeOf3, [this].concat(args)));

                _defineProperty(_assertThisInitialized(_this2), "item", null);

                return _this2;
              }

              _createClass(Chest, [{
                key: "interact",
                value: function interact() {
                  if (this.item) {
                    Game.displayMessage("Found a " + this.item.name);
                    Game.player.inventory.push(this.item);
                    this.item = null;
                    this.bgcolor = "purple";
                  } else {
                    Game.displayMessage("The chest is empty");
                  }
                }
              }]);

              return Chest;
            }(GameObject);

            var Manager =
            /*#__PURE__*/
            function () {
              function Manager() {
                _classCallCheck(this, Manager);
              }

              _createClass(Manager, [{
                key: "act",
                value: function act() {
                  // check if the player won
                  var playerWon = true;

                  for (var i = 0; i < Game.actors.length; i++) {
                    var o = Game.actors[i];

                    if (o.fighter) {
                      playerWon = false;
                      break;
                    }
                  }

                  if (playerWon) {
                    Game.displayMessage("You have won");
                    Game.engine.lock();
                  }

                  Game.drawUI();

                  for (var i = 0; i < Game.game_objects.length; i++) {
                    Game.game_objects[i].draw();
                  }

                  for (var i = 0; i < Game.actors.length; i++) {
                    Game.actors[i].draw();
                  }

                  Game.player.draw();
                }
              }]);

              return Manager;
            }();

            var Game = {
              display: null,
              player: null,
              engine: null,
              drawer: null,
              game_objects: [],
              actors: [],
              map: {},
              currentLogLines: [],
              init: function init() {
                this.display = new ROT.Display({
                  width: WIDTH,
                  height: HEIGHT,
                  fontSize: 13
                });
                document.getElementById("canvas").appendChild(this.display.getContainer());
                this.generateMap();
                var scheduler = new ROT.Scheduler.Simple();
                this.manager = new Manager();
                scheduler.add(this.manager, true);
                scheduler.add(this.player, true);

                for (var i = 0; i < this.actors.length; i++) {
                  scheduler.add(this.actors[i], true);
                }

                this.engine = new ROT.Engine(scheduler);
                this.engine.start();
              },
              isBlocked: function isBlocked(x, y) {
                //first test the map tile
                if (this.map[x + "," + y] !== ".") {
                  return true;
                } //now check for any blocking objects


                for (var i = 0; i < this.game_objects.length; i++) {
                  var object = this.game_objects[i];

                  if (object.blocks && object.x == x && object.y == y) {
                    return true;
                  }
                }

                for (var i = 0; i < this.actors.length; i++) {
                  var actor = this.actors[i];

                  if (actor.blocks && actor.x == x && actor.y == y) {
                    return true;
                  }
                }

                return false;
              },
              generateMap: function generateMap() {
                var cellular = new ROT.Map.Cellular(WIDTH, HEIGHT - 5, {
                  connected: true
                });
                cellular.randomize(0.5);
                var generations = Math.max(1, Math.floor(ROT.RNG.getNormal(4, 2)));

                for (var i = 0; i < generations; i++) {
                  cellular.create();
                }

                var freeCells = [];

                var digCallback = function digCallback(x, y, value) {
                  var key = x + "," + y;

                  if (!value) {
                    this.map[key] = "#";
                  } else {
                    this.map[key] = ".";
                    freeCells.push(key);
                  }
                };

                cellular.create(digCallback.bind(this)); // place stuff before the connections are made

                this.player = this.createBeing(Player, "@", "blue", "white", "Player", true, freeCells, new Fighter(100, 100, 10, 1, Player.die));
                this.actors.push(this.createBeing(GameObject, "G", "green", "white", "Goblin", true, freeCells, new Fighter(30, 30, ROT.RNG.getItem([10, 20]), 1, BasicMonster.die), new BasicMonster()));
                this.actors.push(this.createBeing(GameObject, "G", "green", "white", "Goblin", true, freeCells, new Fighter(30, 30, ROT.RNG.getItem([10, 20]), 1, BasicMonster.die), new BasicMonster()));
                this.generateChests();
                cellular.connect(digCallback.bind(this), 1);
                this.drawWholeMap();
                this.player.draw();
                this.actors.forEach(function (i) {
                  i.draw();
                });
                this.game_objects.forEach(function (i) {
                  i.draw();
                });
                this.drawUI();
              },
              drawWholeMap: function drawWholeMap() {
                for (var key in this.map) {
                  var parts = key.split(",");
                  var x = parseInt(parts[0]);
                  var y = parseInt(parts[1]);
                  this.drawTile(key, x, y);
                }
              },
              drawTile: function drawTile(key, x, y) {
                var val = this.map[key];
                var fgcolor;
                var bgcolor;

                switch (val) {
                  case "#":
                    fgcolor = "#000";
                    bgcolor = "#000";
                    break;

                  case ".":
                    fgcolor = "#fff";
                    bgcolor = "#fff";
                    break;

                  case "*":
                    fgcolor = "brown";
                    bgcolor = "#fff";
                    break;

                  default:
                    fgcolor = "#fff";
                    bgcolor = "#000";
                    break;
                }

                this.display.draw(x, y, val, fgcolor, bgcolor);
              },
              drawUI: function drawUI() {
                for (var i = 0; i < WIDTH; i++) {
                  this.display.draw(i, HEIGHT - 4, "#", "blue", "blue");
                }

                this.display.drawText(0, HEIGHT - 4, "%c{white}%b{blue}HP: " + this.player.fighter.hp);
                this.display.drawText(10, HEIGHT - 4, "%c{white}%b{blue}STR: " + this.player.fighter.strength);
                this.display.drawText(20, HEIGHT - 4, "%c{white}%b{blue}DEF: " + this.player.fighter.defense);
              },
              displayMessage: function displayMessage(text) {
                for (var i = 0; i < WIDTH; i++) {
                  this.display.draw(i, HEIGHT - 3, "#", "black", "black");
                  this.display.draw(i, HEIGHT - 2, "#", "black", "black");
                  this.display.draw(i, HEIGHT - 1, "#", "black", "black");
                }

                if (this.currentLogLines.length === 3) {
                  this.currentLogLines.splice(0, 1);
                }

                this.currentLogLines.push(text);

                for (var d = 0; d < this.currentLogLines.length; d++) {
                  this.display.drawText(0, HEIGHT - 3 + d, "%c{white}" + this.currentLogLines[d]);
                }
              },
              generateChests: function generateChests() {
                var num = Number.parseInt(ROT.RNG.getWeightedValue({
                  "0": 2,
                  "1": 7,
                  "2": 3,
                  "3": 1
                }));
                var keys = Object.keys(this.map);
                var cellx, celly;

                for (var i = 0; i < num; i++) {
                  // find a free space
                  while (this.isBlocked(cellx, celly)) {
                    var option = ROT.RNG.getItem(keys).split(",");
                    cellx = Number.parseInt(option[0]);
                    celly = Number.parseInt(option[1]);
                  }

                  var c = new Chest(cellx, celly, "*", "white", "brown", "Chest", true);
                  c.item = createHealthPotion(10);
                  this.game_objects.push(c);
                  cellx = null;
                  celly = null;
                }
              },
              createBeing: function createBeing(what, char, fgcolor, bgcolor, name, blocks, freeCells) {
                var fighter = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
                var ai = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
                var index = Math.floor(ROT.RNG.getUniform() * freeCells.length);
                var key = freeCells.splice(index, 1)[0];
                var parts = key.split(",");
                var x = parseInt(parts[0]);
                var y = parseInt(parts[1]);
                return new what(x, y, char, fgcolor, bgcolor, name, blocks, fighter, ai);
              }
            };
            Game.init();
        </script>
  </body>
</html>